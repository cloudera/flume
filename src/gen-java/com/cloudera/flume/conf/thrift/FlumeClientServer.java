/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.cloudera.flume.conf.thrift;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

public class FlumeClientServer {

  public interface Iface {

    public boolean heartbeat(String logicalNode, String physicalNode, String host, FlumeNodeState s, long timestamp) throws TException;

    public ThriftFlumeConfigData getConfig(String sourceId) throws TException;

    public List<String> getLogicalNodes(String physNode) throws TException;

    public void acknowledge(String ackid) throws TException;

    public boolean checkAck(String ackid) throws TException;

    public void putReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports) throws TException;

  }

  public interface AsyncIface {

    public void heartbeat(String logicalNode, String physicalNode, String host, FlumeNodeState s, long timestamp, AsyncMethodCallback<AsyncClient.heartbeat_call> resultHandler) throws TException;

    public void getConfig(String sourceId, AsyncMethodCallback<AsyncClient.getConfig_call> resultHandler) throws TException;

    public void getLogicalNodes(String physNode, AsyncMethodCallback<AsyncClient.getLogicalNodes_call> resultHandler) throws TException;

    public void acknowledge(String ackid, AsyncMethodCallback<AsyncClient.acknowledge_call> resultHandler) throws TException;

    public void checkAck(String ackid, AsyncMethodCallback<AsyncClient.checkAck_call> resultHandler) throws TException;

    public void putReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports, AsyncMethodCallback<AsyncClient.putReports_call> resultHandler) throws TException;

  }

  public static class Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public boolean heartbeat(String logicalNode, String physicalNode, String host, FlumeNodeState s, long timestamp) throws TException
    {
      send_heartbeat(logicalNode, physicalNode, host, s, timestamp);
      return recv_heartbeat();
    }

    public void send_heartbeat(String logicalNode, String physicalNode, String host, FlumeNodeState s, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("heartbeat", TMessageType.CALL, ++seqid_));
      heartbeat_args args = new heartbeat_args();
      args.setLogicalNode(logicalNode);
      args.setPhysicalNode(physicalNode);
      args.setHost(host);
      args.setS(s);
      args.setTimestamp(timestamp);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_heartbeat() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "heartbeat failed: out of sequence response");
      }
      heartbeat_result result = new heartbeat_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "heartbeat failed: unknown result");
    }

    public ThriftFlumeConfigData getConfig(String sourceId) throws TException
    {
      send_getConfig(sourceId);
      return recv_getConfig();
    }

    public void send_getConfig(String sourceId) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, ++seqid_));
      getConfig_args args = new getConfig_args();
      args.setSourceId(sourceId);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ThriftFlumeConfigData recv_getConfig() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getConfig failed: out of sequence response");
      }
      getConfig_result result = new getConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConfig failed: unknown result");
    }

    public List<String> getLogicalNodes(String physNode) throws TException
    {
      send_getLogicalNodes(physNode);
      return recv_getLogicalNodes();
    }

    public void send_getLogicalNodes(String physNode) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getLogicalNodes", TMessageType.CALL, ++seqid_));
      getLogicalNodes_args args = new getLogicalNodes_args();
      args.setPhysNode(physNode);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getLogicalNodes() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getLogicalNodes failed: out of sequence response");
      }
      getLogicalNodes_result result = new getLogicalNodes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getLogicalNodes failed: unknown result");
    }

    public void acknowledge(String ackid) throws TException
    {
      send_acknowledge(ackid);
      recv_acknowledge();
    }

    public void send_acknowledge(String ackid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("acknowledge", TMessageType.CALL, ++seqid_));
      acknowledge_args args = new acknowledge_args();
      args.setAckid(ackid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_acknowledge() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "acknowledge failed: out of sequence response");
      }
      acknowledge_result result = new acknowledge_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public boolean checkAck(String ackid) throws TException
    {
      send_checkAck(ackid);
      return recv_checkAck();
    }

    public void send_checkAck(String ackid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("checkAck", TMessageType.CALL, ++seqid_));
      checkAck_args args = new checkAck_args();
      args.setAckid(ackid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_checkAck() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "checkAck failed: out of sequence response");
      }
      checkAck_result result = new checkAck_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "checkAck failed: unknown result");
    }

    public void putReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports) throws TException
    {
      send_putReports(reports);
      recv_putReports();
    }

    public void send_putReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("putReports", TMessageType.CALL, ++seqid_));
      putReports_args args = new putReports_args();
      args.setReports(reports);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_putReports() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "putReports failed: out of sequence response");
      }
      putReports_result result = new putReports_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void heartbeat(String logicalNode, String physicalNode, String host, FlumeNodeState s, long timestamp, AsyncMethodCallback<heartbeat_call> resultHandler) throws TException {
      checkReady();
      heartbeat_call method_call = new heartbeat_call(logicalNode, physicalNode, host, s, timestamp, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class heartbeat_call extends TAsyncMethodCall {
      private String logicalNode;
      private String physicalNode;
      private String host;
      private FlumeNodeState s;
      private long timestamp;
      public heartbeat_call(String logicalNode, String physicalNode, String host, FlumeNodeState s, long timestamp, AsyncMethodCallback<heartbeat_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.logicalNode = logicalNode;
        this.physicalNode = physicalNode;
        this.host = host;
        this.s = s;
        this.timestamp = timestamp;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("heartbeat", TMessageType.CALL, 0));
        heartbeat_args args = new heartbeat_args();
        args.setLogicalNode(logicalNode);
        args.setPhysicalNode(physicalNode);
        args.setHost(host);
        args.setS(s);
        args.setTimestamp(timestamp);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_heartbeat();
      }
    }

    public void getConfig(String sourceId, AsyncMethodCallback<getConfig_call> resultHandler) throws TException {
      checkReady();
      getConfig_call method_call = new getConfig_call(sourceId, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getConfig_call extends TAsyncMethodCall {
      private String sourceId;
      public getConfig_call(String sourceId, AsyncMethodCallback<getConfig_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.sourceId = sourceId;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, 0));
        getConfig_args args = new getConfig_args();
        args.setSourceId(sourceId);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ThriftFlumeConfigData getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getConfig();
      }
    }

    public void getLogicalNodes(String physNode, AsyncMethodCallback<getLogicalNodes_call> resultHandler) throws TException {
      checkReady();
      getLogicalNodes_call method_call = new getLogicalNodes_call(physNode, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getLogicalNodes_call extends TAsyncMethodCall {
      private String physNode;
      public getLogicalNodes_call(String physNode, AsyncMethodCallback<getLogicalNodes_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.physNode = physNode;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getLogicalNodes", TMessageType.CALL, 0));
        getLogicalNodes_args args = new getLogicalNodes_args();
        args.setPhysNode(physNode);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getLogicalNodes();
      }
    }

    public void acknowledge(String ackid, AsyncMethodCallback<acknowledge_call> resultHandler) throws TException {
      checkReady();
      acknowledge_call method_call = new acknowledge_call(ackid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class acknowledge_call extends TAsyncMethodCall {
      private String ackid;
      public acknowledge_call(String ackid, AsyncMethodCallback<acknowledge_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ackid = ackid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("acknowledge", TMessageType.CALL, 0));
        acknowledge_args args = new acknowledge_args();
        args.setAckid(ackid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_acknowledge();
      }
    }

    public void checkAck(String ackid, AsyncMethodCallback<checkAck_call> resultHandler) throws TException {
      checkReady();
      checkAck_call method_call = new checkAck_call(ackid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class checkAck_call extends TAsyncMethodCall {
      private String ackid;
      public checkAck_call(String ackid, AsyncMethodCallback<checkAck_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ackid = ackid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("checkAck", TMessageType.CALL, 0));
        checkAck_args args = new checkAck_args();
        args.setAckid(ackid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_checkAck();
      }
    }

    public void putReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports, AsyncMethodCallback<putReports_call> resultHandler) throws TException {
      checkReady();
      putReports_call method_call = new putReports_call(reports, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class putReports_call extends TAsyncMethodCall {
      private Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports;
      public putReports_call(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports, AsyncMethodCallback<putReports_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.reports = reports;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("putReports", TMessageType.CALL, 0));
        putReports_args args = new putReports_args();
        args.setReports(reports);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_putReports();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("heartbeat", new heartbeat());
      processMap_.put("getConfig", new getConfig());
      processMap_.put("getLogicalNodes", new getLogicalNodes());
      processMap_.put("acknowledge", new acknowledge());
      processMap_.put("checkAck", new checkAck());
      processMap_.put("putReports", new putReports());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class heartbeat implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        heartbeat_args args = new heartbeat_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("heartbeat", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        heartbeat_result result = new heartbeat_result();
        result.success = iface_.heartbeat(args.logicalNode, args.physicalNode, args.host, args.s, args.timestamp);
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("heartbeat", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getConfig_args args = new getConfig_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getConfig", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getConfig_result result = new getConfig_result();
        result.success = iface_.getConfig(args.sourceId);
        oprot.writeMessageBegin(new TMessage("getConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getLogicalNodes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getLogicalNodes_args args = new getLogicalNodes_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getLogicalNodes", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getLogicalNodes_result result = new getLogicalNodes_result();
        result.success = iface_.getLogicalNodes(args.physNode);
        oprot.writeMessageBegin(new TMessage("getLogicalNodes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class acknowledge implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        acknowledge_args args = new acknowledge_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("acknowledge", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        acknowledge_result result = new acknowledge_result();
        iface_.acknowledge(args.ackid);
        oprot.writeMessageBegin(new TMessage("acknowledge", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class checkAck implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        checkAck_args args = new checkAck_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("checkAck", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        checkAck_result result = new checkAck_result();
        result.success = iface_.checkAck(args.ackid);
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("checkAck", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class putReports implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        putReports_args args = new putReports_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("putReports", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        putReports_result result = new putReports_result();
        iface_.putReports(args.reports);
        oprot.writeMessageBegin(new TMessage("putReports", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class heartbeat_args implements TBase<heartbeat_args, heartbeat_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("heartbeat_args");

    private static final TField LOGICAL_NODE_FIELD_DESC = new TField("logicalNode", TType.STRING, (short)1);
    private static final TField PHYSICAL_NODE_FIELD_DESC = new TField("physicalNode", TType.STRING, (short)4);
    private static final TField HOST_FIELD_DESC = new TField("host", TType.STRING, (short)5);
    private static final TField S_FIELD_DESC = new TField("s", TType.I32, (short)2);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)3);

    public String logicalNode;
    public String physicalNode;
    public String host;
    /**
     * 
     * @see FlumeNodeState
     */
    public FlumeNodeState s;
    public long timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      LOGICAL_NODE((short)1, "logicalNode"),
      PHYSICAL_NODE((short)4, "physicalNode"),
      HOST((short)5, "host"),
      /**
       * 
       * @see FlumeNodeState
       */
      S((short)2, "s"),
      TIMESTAMP((short)3, "timestamp");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // LOGICAL_NODE
            return LOGICAL_NODE;
          case 4: // PHYSICAL_NODE
            return PHYSICAL_NODE;
          case 5: // HOST
            return HOST;
          case 2: // S
            return S;
          case 3: // TIMESTAMP
            return TIMESTAMP;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.LOGICAL_NODE, new FieldMetaData("logicalNode", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PHYSICAL_NODE, new FieldMetaData("physicalNode", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.HOST, new FieldMetaData("host", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.S, new FieldMetaData("s", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, FlumeNodeState.class)));
      tmpMap.put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(heartbeat_args.class, metaDataMap);
    }

    public heartbeat_args() {
    }

    public heartbeat_args(
      String logicalNode,
      String physicalNode,
      String host,
      FlumeNodeState s,
      long timestamp)
    {
      this();
      this.logicalNode = logicalNode;
      this.physicalNode = physicalNode;
      this.host = host;
      this.s = s;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartbeat_args(heartbeat_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetLogicalNode()) {
        this.logicalNode = other.logicalNode;
      }
      if (other.isSetPhysicalNode()) {
        this.physicalNode = other.physicalNode;
      }
      if (other.isSetHost()) {
        this.host = other.host;
      }
      if (other.isSetS()) {
        this.s = other.s;
      }
      this.timestamp = other.timestamp;
    }

    public heartbeat_args deepCopy() {
      return new heartbeat_args(this);
    }

    @Deprecated
    public heartbeat_args clone() {
      return new heartbeat_args(this);
    }

    @Override
    public void clear() {
      this.logicalNode = null;
      this.physicalNode = null;
      this.host = null;
      this.s = null;
      setTimestampIsSet(false);
      this.timestamp = 0;
    }

    public String getLogicalNode() {
      return this.logicalNode;
    }

    public heartbeat_args setLogicalNode(String logicalNode) {
      this.logicalNode = logicalNode;
      return this;
    }

    public void unsetLogicalNode() {
      this.logicalNode = null;
    }

    /** Returns true if field logicalNode is set (has been asigned a value) and false otherwise */
    public boolean isSetLogicalNode() {
      return this.logicalNode != null;
    }

    public void setLogicalNodeIsSet(boolean value) {
      if (!value) {
        this.logicalNode = null;
      }
    }

    public String getPhysicalNode() {
      return this.physicalNode;
    }

    public heartbeat_args setPhysicalNode(String physicalNode) {
      this.physicalNode = physicalNode;
      return this;
    }

    public void unsetPhysicalNode() {
      this.physicalNode = null;
    }

    /** Returns true if field physicalNode is set (has been asigned a value) and false otherwise */
    public boolean isSetPhysicalNode() {
      return this.physicalNode != null;
    }

    public void setPhysicalNodeIsSet(boolean value) {
      if (!value) {
        this.physicalNode = null;
      }
    }

    public String getHost() {
      return this.host;
    }

    public heartbeat_args setHost(String host) {
      this.host = host;
      return this;
    }

    public void unsetHost() {
      this.host = null;
    }

    /** Returns true if field host is set (has been asigned a value) and false otherwise */
    public boolean isSetHost() {
      return this.host != null;
    }

    public void setHostIsSet(boolean value) {
      if (!value) {
        this.host = null;
      }
    }

    /**
     * 
     * @see FlumeNodeState
     */
    public FlumeNodeState getS() {
      return this.s;
    }

    /**
     * 
     * @see FlumeNodeState
     */
    public heartbeat_args setS(FlumeNodeState s) {
      this.s = s;
      return this;
    }

    public void unsetS() {
      this.s = null;
    }

    /** Returns true if field s is set (has been asigned a value) and false otherwise */
    public boolean isSetS() {
      return this.s != null;
    }

    public void setSIsSet(boolean value) {
      if (!value) {
        this.s = null;
      }
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public heartbeat_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case LOGICAL_NODE:
        if (value == null) {
          unsetLogicalNode();
        } else {
          setLogicalNode((String)value);
        }
        break;

      case PHYSICAL_NODE:
        if (value == null) {
          unsetPhysicalNode();
        } else {
          setPhysicalNode((String)value);
        }
        break;

      case HOST:
        if (value == null) {
          unsetHost();
        } else {
          setHost((String)value);
        }
        break;

      case S:
        if (value == null) {
          unsetS();
        } else {
          setS((FlumeNodeState)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case LOGICAL_NODE:
        return getLogicalNode();

      case PHYSICAL_NODE:
        return getPhysicalNode();

      case HOST:
        return getHost();

      case S:
        return getS();

      case TIMESTAMP:
        return new Long(getTimestamp());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case LOGICAL_NODE:
        return isSetLogicalNode();
      case PHYSICAL_NODE:
        return isSetPhysicalNode();
      case HOST:
        return isSetHost();
      case S:
        return isSetS();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof heartbeat_args)
        return this.equals((heartbeat_args)that);
      return false;
    }

    public boolean equals(heartbeat_args that) {
      if (that == null)
        return false;

      boolean this_present_logicalNode = true && this.isSetLogicalNode();
      boolean that_present_logicalNode = true && that.isSetLogicalNode();
      if (this_present_logicalNode || that_present_logicalNode) {
        if (!(this_present_logicalNode && that_present_logicalNode))
          return false;
        if (!this.logicalNode.equals(that.logicalNode))
          return false;
      }

      boolean this_present_physicalNode = true && this.isSetPhysicalNode();
      boolean that_present_physicalNode = true && that.isSetPhysicalNode();
      if (this_present_physicalNode || that_present_physicalNode) {
        if (!(this_present_physicalNode && that_present_physicalNode))
          return false;
        if (!this.physicalNode.equals(that.physicalNode))
          return false;
      }

      boolean this_present_host = true && this.isSetHost();
      boolean that_present_host = true && that.isSetHost();
      if (this_present_host || that_present_host) {
        if (!(this_present_host && that_present_host))
          return false;
        if (!this.host.equals(that.host))
          return false;
      }

      boolean this_present_s = true && this.isSetS();
      boolean that_present_s = true && that.isSetS();
      if (this_present_s || that_present_s) {
        if (!(this_present_s && that_present_s))
          return false;
        if (!this.s.equals(that.s))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(heartbeat_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      heartbeat_args typedOther = (heartbeat_args)other;

      lastComparison = Boolean.valueOf(isSetLogicalNode()).compareTo(typedOther.isSetLogicalNode());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLogicalNode()) {        lastComparison = TBaseHelper.compareTo(this.logicalNode, typedOther.logicalNode);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPhysicalNode()).compareTo(typedOther.isSetPhysicalNode());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPhysicalNode()) {        lastComparison = TBaseHelper.compareTo(this.physicalNode, typedOther.physicalNode);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetHost()).compareTo(typedOther.isSetHost());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetHost()) {        lastComparison = TBaseHelper.compareTo(this.host, typedOther.host);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetS()).compareTo(typedOther.isSetS());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetS()) {        lastComparison = TBaseHelper.compareTo(this.s, typedOther.s);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimestamp()) {        lastComparison = TBaseHelper.compareTo(this.timestamp, typedOther.timestamp);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // LOGICAL_NODE
            if (field.type == TType.STRING) {
              this.logicalNode = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // PHYSICAL_NODE
            if (field.type == TType.STRING) {
              this.physicalNode = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // HOST
            if (field.type == TType.STRING) {
              this.host = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // S
            if (field.type == TType.I32) {
              this.s = FlumeNodeState.findByValue(iprot.readI32());
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TIMESTAMP
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.logicalNode != null) {
        oprot.writeFieldBegin(LOGICAL_NODE_FIELD_DESC);
        oprot.writeString(this.logicalNode);
        oprot.writeFieldEnd();
      }
      if (this.s != null) {
        oprot.writeFieldBegin(S_FIELD_DESC);
        oprot.writeI32(this.s.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      if (this.physicalNode != null) {
        oprot.writeFieldBegin(PHYSICAL_NODE_FIELD_DESC);
        oprot.writeString(this.physicalNode);
        oprot.writeFieldEnd();
      }
      if (this.host != null) {
        oprot.writeFieldBegin(HOST_FIELD_DESC);
        oprot.writeString(this.host);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("heartbeat_args(");
      boolean first = true;

      sb.append("logicalNode:");
      if (this.logicalNode == null) {
        sb.append("null");
      } else {
        sb.append(this.logicalNode);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("physicalNode:");
      if (this.physicalNode == null) {
        sb.append("null");
      } else {
        sb.append(this.physicalNode);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("host:");
      if (this.host == null) {
        sb.append("null");
      } else {
        sb.append(this.host);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("s:");
      if (this.s == null) {
        sb.append("null");
      } else {
        sb.append(this.s);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class heartbeat_result implements TBase<heartbeat_result, heartbeat_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("heartbeat_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(heartbeat_result.class, metaDataMap);
    }

    public heartbeat_result() {
    }

    public heartbeat_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public heartbeat_result(heartbeat_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public heartbeat_result deepCopy() {
      return new heartbeat_result(this);
    }

    @Deprecated
    public heartbeat_result clone() {
      return new heartbeat_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public heartbeat_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof heartbeat_result)
        return this.equals((heartbeat_result)that);
      return false;
    }

    public boolean equals(heartbeat_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(heartbeat_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      heartbeat_result typedOther = (heartbeat_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("heartbeat_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_args implements TBase<getConfig_args, getConfig_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_args");

    private static final TField SOURCE_ID_FIELD_DESC = new TField("sourceId", TType.STRING, (short)1);

    public String sourceId;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SOURCE_ID((short)1, "sourceId");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SOURCE_ID
            return SOURCE_ID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SOURCE_ID, new FieldMetaData("sourceId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getConfig_args.class, metaDataMap);
    }

    public getConfig_args() {
    }

    public getConfig_args(
      String sourceId)
    {
      this();
      this.sourceId = sourceId;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_args(getConfig_args other) {
      if (other.isSetSourceId()) {
        this.sourceId = other.sourceId;
      }
    }

    public getConfig_args deepCopy() {
      return new getConfig_args(this);
    }

    @Deprecated
    public getConfig_args clone() {
      return new getConfig_args(this);
    }

    @Override
    public void clear() {
      this.sourceId = null;
    }

    public String getSourceId() {
      return this.sourceId;
    }

    public getConfig_args setSourceId(String sourceId) {
      this.sourceId = sourceId;
      return this;
    }

    public void unsetSourceId() {
      this.sourceId = null;
    }

    /** Returns true if field sourceId is set (has been asigned a value) and false otherwise */
    public boolean isSetSourceId() {
      return this.sourceId != null;
    }

    public void setSourceIdIsSet(boolean value) {
      if (!value) {
        this.sourceId = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SOURCE_ID:
        if (value == null) {
          unsetSourceId();
        } else {
          setSourceId((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SOURCE_ID:
        return getSourceId();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SOURCE_ID:
        return isSetSourceId();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_args)
        return this.equals((getConfig_args)that);
      return false;
    }

    public boolean equals(getConfig_args that) {
      if (that == null)
        return false;

      boolean this_present_sourceId = true && this.isSetSourceId();
      boolean that_present_sourceId = true && that.isSetSourceId();
      if (this_present_sourceId || that_present_sourceId) {
        if (!(this_present_sourceId && that_present_sourceId))
          return false;
        if (!this.sourceId.equals(that.sourceId))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConfig_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConfig_args typedOther = (getConfig_args)other;

      lastComparison = Boolean.valueOf(isSetSourceId()).compareTo(typedOther.isSetSourceId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSourceId()) {        lastComparison = TBaseHelper.compareTo(this.sourceId, typedOther.sourceId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SOURCE_ID
            if (field.type == TType.STRING) {
              this.sourceId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.sourceId != null) {
        oprot.writeFieldBegin(SOURCE_ID_FIELD_DESC);
        oprot.writeString(this.sourceId);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getConfig_args(");
      boolean first = true;

      sb.append("sourceId:");
      if (this.sourceId == null) {
        sb.append("null");
      } else {
        sb.append(this.sourceId);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_result implements TBase<getConfig_result, getConfig_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ThriftFlumeConfigData success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftFlumeConfigData.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getConfig_result.class, metaDataMap);
    }

    public getConfig_result() {
    }

    public getConfig_result(
      ThriftFlumeConfigData success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_result(getConfig_result other) {
      if (other.isSetSuccess()) {
        this.success = new ThriftFlumeConfigData(other.success);
      }
    }

    public getConfig_result deepCopy() {
      return new getConfig_result(this);
    }

    @Deprecated
    public getConfig_result clone() {
      return new getConfig_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public ThriftFlumeConfigData getSuccess() {
      return this.success;
    }

    public getConfig_result setSuccess(ThriftFlumeConfigData success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ThriftFlumeConfigData)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_result)
        return this.equals((getConfig_result)that);
      return false;
    }

    public boolean equals(getConfig_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConfig_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConfig_result typedOther = (getConfig_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new ThriftFlumeConfigData();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getConfig_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getLogicalNodes_args implements TBase<getLogicalNodes_args, getLogicalNodes_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getLogicalNodes_args");

    private static final TField PHYS_NODE_FIELD_DESC = new TField("physNode", TType.STRING, (short)1);

    public String physNode;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PHYS_NODE((short)1, "physNode");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PHYS_NODE
            return PHYS_NODE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PHYS_NODE, new FieldMetaData("physNode", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getLogicalNodes_args.class, metaDataMap);
    }

    public getLogicalNodes_args() {
    }

    public getLogicalNodes_args(
      String physNode)
    {
      this();
      this.physNode = physNode;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getLogicalNodes_args(getLogicalNodes_args other) {
      if (other.isSetPhysNode()) {
        this.physNode = other.physNode;
      }
    }

    public getLogicalNodes_args deepCopy() {
      return new getLogicalNodes_args(this);
    }

    @Deprecated
    public getLogicalNodes_args clone() {
      return new getLogicalNodes_args(this);
    }

    @Override
    public void clear() {
      this.physNode = null;
    }

    public String getPhysNode() {
      return this.physNode;
    }

    public getLogicalNodes_args setPhysNode(String physNode) {
      this.physNode = physNode;
      return this;
    }

    public void unsetPhysNode() {
      this.physNode = null;
    }

    /** Returns true if field physNode is set (has been asigned a value) and false otherwise */
    public boolean isSetPhysNode() {
      return this.physNode != null;
    }

    public void setPhysNodeIsSet(boolean value) {
      if (!value) {
        this.physNode = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PHYS_NODE:
        if (value == null) {
          unsetPhysNode();
        } else {
          setPhysNode((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PHYS_NODE:
        return getPhysNode();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case PHYS_NODE:
        return isSetPhysNode();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getLogicalNodes_args)
        return this.equals((getLogicalNodes_args)that);
      return false;
    }

    public boolean equals(getLogicalNodes_args that) {
      if (that == null)
        return false;

      boolean this_present_physNode = true && this.isSetPhysNode();
      boolean that_present_physNode = true && that.isSetPhysNode();
      if (this_present_physNode || that_present_physNode) {
        if (!(this_present_physNode && that_present_physNode))
          return false;
        if (!this.physNode.equals(that.physNode))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getLogicalNodes_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getLogicalNodes_args typedOther = (getLogicalNodes_args)other;

      lastComparison = Boolean.valueOf(isSetPhysNode()).compareTo(typedOther.isSetPhysNode());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPhysNode()) {        lastComparison = TBaseHelper.compareTo(this.physNode, typedOther.physNode);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PHYS_NODE
            if (field.type == TType.STRING) {
              this.physNode = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.physNode != null) {
        oprot.writeFieldBegin(PHYS_NODE_FIELD_DESC);
        oprot.writeString(this.physNode);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getLogicalNodes_args(");
      boolean first = true;

      sb.append("physNode:");
      if (this.physNode == null) {
        sb.append("null");
      } else {
        sb.append(this.physNode);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getLogicalNodes_result implements TBase<getLogicalNodes_result, getLogicalNodes_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getLogicalNodes_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<String> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getLogicalNodes_result.class, metaDataMap);
    }

    public getLogicalNodes_result() {
    }

    public getLogicalNodes_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getLogicalNodes_result(getLogicalNodes_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    public getLogicalNodes_result deepCopy() {
      return new getLogicalNodes_result(this);
    }

    @Deprecated
    public getLogicalNodes_result clone() {
      return new getLogicalNodes_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public getLogicalNodes_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getLogicalNodes_result)
        return this.equals((getLogicalNodes_result)that);
      return false;
    }

    public boolean equals(getLogicalNodes_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getLogicalNodes_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getLogicalNodes_result typedOther = (getLogicalNodes_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list0 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list0.size);
                for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                {
                  String _elem2;
                  _elem2 = iprot.readString();
                  this.success.add(_elem2);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter3 : this.success)
          {
            oprot.writeString(_iter3);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getLogicalNodes_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class acknowledge_args implements TBase<acknowledge_args, acknowledge_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("acknowledge_args");

    private static final TField ACKID_FIELD_DESC = new TField("ackid", TType.STRING, (short)1);

    public String ackid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ACKID((short)1, "ackid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ACKID
            return ACKID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ACKID, new FieldMetaData("ackid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(acknowledge_args.class, metaDataMap);
    }

    public acknowledge_args() {
    }

    public acknowledge_args(
      String ackid)
    {
      this();
      this.ackid = ackid;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public acknowledge_args(acknowledge_args other) {
      if (other.isSetAckid()) {
        this.ackid = other.ackid;
      }
    }

    public acknowledge_args deepCopy() {
      return new acknowledge_args(this);
    }

    @Deprecated
    public acknowledge_args clone() {
      return new acknowledge_args(this);
    }

    @Override
    public void clear() {
      this.ackid = null;
    }

    public String getAckid() {
      return this.ackid;
    }

    public acknowledge_args setAckid(String ackid) {
      this.ackid = ackid;
      return this;
    }

    public void unsetAckid() {
      this.ackid = null;
    }

    /** Returns true if field ackid is set (has been asigned a value) and false otherwise */
    public boolean isSetAckid() {
      return this.ackid != null;
    }

    public void setAckidIsSet(boolean value) {
      if (!value) {
        this.ackid = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ACKID:
        if (value == null) {
          unsetAckid();
        } else {
          setAckid((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ACKID:
        return getAckid();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case ACKID:
        return isSetAckid();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof acknowledge_args)
        return this.equals((acknowledge_args)that);
      return false;
    }

    public boolean equals(acknowledge_args that) {
      if (that == null)
        return false;

      boolean this_present_ackid = true && this.isSetAckid();
      boolean that_present_ackid = true && that.isSetAckid();
      if (this_present_ackid || that_present_ackid) {
        if (!(this_present_ackid && that_present_ackid))
          return false;
        if (!this.ackid.equals(that.ackid))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(acknowledge_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      acknowledge_args typedOther = (acknowledge_args)other;

      lastComparison = Boolean.valueOf(isSetAckid()).compareTo(typedOther.isSetAckid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAckid()) {        lastComparison = TBaseHelper.compareTo(this.ackid, typedOther.ackid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // ACKID
            if (field.type == TType.STRING) {
              this.ackid = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.ackid != null) {
        oprot.writeFieldBegin(ACKID_FIELD_DESC);
        oprot.writeString(this.ackid);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("acknowledge_args(");
      boolean first = true;

      sb.append("ackid:");
      if (this.ackid == null) {
        sb.append("null");
      } else {
        sb.append(this.ackid);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class acknowledge_result implements TBase<acknowledge_result, acknowledge_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("acknowledge_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(acknowledge_result.class, metaDataMap);
    }

    public acknowledge_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public acknowledge_result(acknowledge_result other) {
    }

    public acknowledge_result deepCopy() {
      return new acknowledge_result(this);
    }

    @Deprecated
    public acknowledge_result clone() {
      return new acknowledge_result(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof acknowledge_result)
        return this.equals((acknowledge_result)that);
      return false;
    }

    public boolean equals(acknowledge_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(acknowledge_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      acknowledge_result typedOther = (acknowledge_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("acknowledge_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkAck_args implements TBase<checkAck_args, checkAck_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkAck_args");

    private static final TField ACKID_FIELD_DESC = new TField("ackid", TType.STRING, (short)1);

    public String ackid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ACKID((short)1, "ackid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ACKID
            return ACKID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ACKID, new FieldMetaData("ackid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkAck_args.class, metaDataMap);
    }

    public checkAck_args() {
    }

    public checkAck_args(
      String ackid)
    {
      this();
      this.ackid = ackid;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkAck_args(checkAck_args other) {
      if (other.isSetAckid()) {
        this.ackid = other.ackid;
      }
    }

    public checkAck_args deepCopy() {
      return new checkAck_args(this);
    }

    @Deprecated
    public checkAck_args clone() {
      return new checkAck_args(this);
    }

    @Override
    public void clear() {
      this.ackid = null;
    }

    public String getAckid() {
      return this.ackid;
    }

    public checkAck_args setAckid(String ackid) {
      this.ackid = ackid;
      return this;
    }

    public void unsetAckid() {
      this.ackid = null;
    }

    /** Returns true if field ackid is set (has been asigned a value) and false otherwise */
    public boolean isSetAckid() {
      return this.ackid != null;
    }

    public void setAckidIsSet(boolean value) {
      if (!value) {
        this.ackid = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ACKID:
        if (value == null) {
          unsetAckid();
        } else {
          setAckid((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ACKID:
        return getAckid();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case ACKID:
        return isSetAckid();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkAck_args)
        return this.equals((checkAck_args)that);
      return false;
    }

    public boolean equals(checkAck_args that) {
      if (that == null)
        return false;

      boolean this_present_ackid = true && this.isSetAckid();
      boolean that_present_ackid = true && that.isSetAckid();
      if (this_present_ackid || that_present_ackid) {
        if (!(this_present_ackid && that_present_ackid))
          return false;
        if (!this.ackid.equals(that.ackid))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkAck_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkAck_args typedOther = (checkAck_args)other;

      lastComparison = Boolean.valueOf(isSetAckid()).compareTo(typedOther.isSetAckid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAckid()) {        lastComparison = TBaseHelper.compareTo(this.ackid, typedOther.ackid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // ACKID
            if (field.type == TType.STRING) {
              this.ackid = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.ackid != null) {
        oprot.writeFieldBegin(ACKID_FIELD_DESC);
        oprot.writeString(this.ackid);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkAck_args(");
      boolean first = true;

      sb.append("ackid:");
      if (this.ackid == null) {
        sb.append("null");
      } else {
        sb.append(this.ackid);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkAck_result implements TBase<checkAck_result, checkAck_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkAck_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkAck_result.class, metaDataMap);
    }

    public checkAck_result() {
    }

    public checkAck_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkAck_result(checkAck_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public checkAck_result deepCopy() {
      return new checkAck_result(this);
    }

    @Deprecated
    public checkAck_result clone() {
      return new checkAck_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public checkAck_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkAck_result)
        return this.equals((checkAck_result)that);
      return false;
    }

    public boolean equals(checkAck_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkAck_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkAck_result typedOther = (checkAck_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkAck_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class putReports_args implements TBase<putReports_args, putReports_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("putReports_args");

    private static final TField REPORTS_FIELD_DESC = new TField("reports", TType.MAP, (short)1);

    public Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      REPORTS((short)1, "reports");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // REPORTS
            return REPORTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.REPORTS, new FieldMetaData("reports", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new StructMetaData(TType.STRUCT, com.cloudera.flume.reporter.server.FlumeReport.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(putReports_args.class, metaDataMap);
    }

    public putReports_args() {
    }

    public putReports_args(
      Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports)
    {
      this();
      this.reports = reports;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public putReports_args(putReports_args other) {
      if (other.isSetReports()) {
        Map<String,com.cloudera.flume.reporter.server.FlumeReport> __this__reports = new HashMap<String,com.cloudera.flume.reporter.server.FlumeReport>();
        for (Map.Entry<String, com.cloudera.flume.reporter.server.FlumeReport> other_element : other.reports.entrySet()) {

          String other_element_key = other_element.getKey();
          com.cloudera.flume.reporter.server.FlumeReport other_element_value = other_element.getValue();

          String __this__reports_copy_key = other_element_key;

          com.cloudera.flume.reporter.server.FlumeReport __this__reports_copy_value = new com.cloudera.flume.reporter.server.FlumeReport(other_element_value);

          __this__reports.put(__this__reports_copy_key, __this__reports_copy_value);
        }
        this.reports = __this__reports;
      }
    }

    public putReports_args deepCopy() {
      return new putReports_args(this);
    }

    @Deprecated
    public putReports_args clone() {
      return new putReports_args(this);
    }

    @Override
    public void clear() {
      this.reports = null;
    }

    public int getReportsSize() {
      return (this.reports == null) ? 0 : this.reports.size();
    }

    public void putToReports(String key, com.cloudera.flume.reporter.server.FlumeReport val) {
      if (this.reports == null) {
        this.reports = new HashMap<String,com.cloudera.flume.reporter.server.FlumeReport>();
      }
      this.reports.put(key, val);
    }

    public Map<String,com.cloudera.flume.reporter.server.FlumeReport> getReports() {
      return this.reports;
    }

    public putReports_args setReports(Map<String,com.cloudera.flume.reporter.server.FlumeReport> reports) {
      this.reports = reports;
      return this;
    }

    public void unsetReports() {
      this.reports = null;
    }

    /** Returns true if field reports is set (has been asigned a value) and false otherwise */
    public boolean isSetReports() {
      return this.reports != null;
    }

    public void setReportsIsSet(boolean value) {
      if (!value) {
        this.reports = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case REPORTS:
        if (value == null) {
          unsetReports();
        } else {
          setReports((Map<String,com.cloudera.flume.reporter.server.FlumeReport>)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case REPORTS:
        return getReports();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case REPORTS:
        return isSetReports();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof putReports_args)
        return this.equals((putReports_args)that);
      return false;
    }

    public boolean equals(putReports_args that) {
      if (that == null)
        return false;

      boolean this_present_reports = true && this.isSetReports();
      boolean that_present_reports = true && that.isSetReports();
      if (this_present_reports || that_present_reports) {
        if (!(this_present_reports && that_present_reports))
          return false;
        if (!this.reports.equals(that.reports))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(putReports_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      putReports_args typedOther = (putReports_args)other;

      lastComparison = Boolean.valueOf(isSetReports()).compareTo(typedOther.isSetReports());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetReports()) {        lastComparison = TBaseHelper.compareTo(this.reports, typedOther.reports);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // REPORTS
            if (field.type == TType.MAP) {
              {
                TMap _map4 = iprot.readMapBegin();
                this.reports = new HashMap<String,com.cloudera.flume.reporter.server.FlumeReport>(2*_map4.size);
                for (int _i5 = 0; _i5 < _map4.size; ++_i5)
                {
                  String _key6;
                  com.cloudera.flume.reporter.server.FlumeReport _val7;
                  _key6 = iprot.readString();
                  _val7 = new com.cloudera.flume.reporter.server.FlumeReport();
                  _val7.read(iprot);
                  this.reports.put(_key6, _val7);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.reports != null) {
        oprot.writeFieldBegin(REPORTS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.reports.size()));
          for (Map.Entry<String, com.cloudera.flume.reporter.server.FlumeReport> _iter8 : this.reports.entrySet())
          {
            oprot.writeString(_iter8.getKey());
            _iter8.getValue().write(oprot);
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("putReports_args(");
      boolean first = true;

      sb.append("reports:");
      if (this.reports == null) {
        sb.append("null");
      } else {
        sb.append(this.reports);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class putReports_result implements TBase<putReports_result, putReports_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("putReports_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(putReports_result.class, metaDataMap);
    }

    public putReports_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public putReports_result(putReports_result other) {
    }

    public putReports_result deepCopy() {
      return new putReports_result(this);
    }

    @Deprecated
    public putReports_result clone() {
      return new putReports_result(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof putReports_result)
        return this.equals((putReports_result)that);
      return false;
    }

    public boolean equals(putReports_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(putReports_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      putReports_result typedOther = (putReports_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("putReports_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
